#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;


//拷贝构造函数调用时机
//C++中拷贝构造函数调用时机通常有三种情况
//1 使用一个已经创建完毕的对象来初始化一个新对象
//2 值传递的方式给函数参数传值
//3 以值方式返回局部对象
class person
{
public:
    //构造函数
    person()
    {
        cout << "person默认构造函数调用" << endl;
    }
    person(int aage)
    {
        cout << "person有参构造函数调用" << endl;
        age = aage;
    }
    person(const person& p)//拷贝函数
    {
        cout << "person拷贝构造函数调用" << endl;
        age = p.age;
    }
    //析构函数
    ~person()
    {
        cout << "person析构函数调用" << endl;
    }
    int age;//代表年龄
};
//1 使用一个已经创建完毕的对象来初始化一个新对象
void test01()
{
    person p1(20);
    person p2(p1);//对p1进行拷贝
    cout << "p2的年龄  " << p2.age << endl;
}
//2 值传递的方式给函数参数传值
void work(person p)//值传递的方式 就是拷贝一个临时的副本出来  就是person p=p; 隐函数写法
//下面的实参传给这里的实参  值传递的方式  把数据改了  不会影响原来的数据
{

}
void test02()
{
    person p;//显示法的一种
    work(p);
}
//3 以值方式返回局部对象
person work2()
{
    person p1;//调用的是它 是个局部对象 是值的方式返回 并不会返回这里的p1 按照这个对象拷贝一个新的值返回给test03
    cout << (int*)&p1 << endl;//int*是指针解引用 也就是解析地址
    return p1;//因为执行完之后就会消除 所以这里返回的时候 根据p1创建一个新的对象 然后返回给test03
}
void test03()
{
    person p = work2();
    cout << (int*)&p << endl;//发现和work2里面的地址不一样 所以说明这里接收的p1和work里面创建的p1不是同一个
}
int main()
{
    //test01();
    //test02();
    test03();
    return 0;
}

//构造函数的分类及调用
//两种分类方式
//     按参数分为：有参构造和无参构造(默认构造)
//     按类型分为：普通构造和拷贝构造   不是拷贝构造的都是普通构造
//三种调用方式
//     括号法
//     显示法
//     隐式转换法

//class person
//{
//public:
//    //构造函数
//    person()//这是无参构造 因为没有任何参数 又叫默认构造 因为编译器会默认是无参的
//    {
//        cout << "person的无参构造函数调用" << endl;
//    }
//    person(int a)//这样就有参数了
//    {
//        age = a;//对age就行赋值
//        cout << "person的有参构造函数调用" << endl;
//    }
//    //拷贝构造函数
//    person(const person& p)//因为要拷贝 所以这里传的也是一份person 按照传进来的属性 拷一份再放到新的这个上面
//        //加const 不能把原来的对象改了
//    {
//        //将传入对象的所有属性，传到新的对象的身上
//        age = p.age;//这样就是一个拷贝操作
//        cout << "person的拷贝函数调用" << endl;
//    }
//    ~person()
//    {
//        cout << "person析构函数调用" << endl;
//    }
//    int age;
//};
////调用
//void test01()
//{
//    ////括号法
//    //person p1;//默认构造函数的调用
//    //person p2(10);//因为传了参数 所以是有参函数调用
//    ////用括号法调用拷贝构造函数
//    //person p3(p2);//因为是拷贝函数 拷贝的是p2
//    ////注意事项：调用默认构造函数的时候，不要加()
//    ////person p();//不会创建对象 因为编译器会认为是函数的声明  不会认为是创建对象
//    //cout << "p2的年龄  " << p2.age << endl;
//    //cout << "p3的年龄  " << p3.age << endl;
//
//    //显示法
//    person p1;
//    person p2 = person(10);//有参构造  显示调用的是一个整型数据
//    person p3 = person(p2);//拷贝构造
//
//    //person(10);//把等号右边单独拿出来 叫匿名对象 等号左侧就是这个对象名
//    ////匿名对象特点：当前行执行结束后 系统会立即回收掉匿名对象
//    //cout << "sdaa" << endl;//还没打印这个的时候 person(10) 就被系统回收了 回收之后才打印的匿名对象
//
//    //注意事项二：不要利用拷贝构造函数 初始化匿名对象
//    //person(p3);//使用匿名对象拷贝p3 会报错 提示person p3 重定义  因为编译器会认为person(p3)==person p3
//
//    //隐式转换法
//    person p4 = 10;//相当于 写了代码 person p4=person(10);  也是有参调用
//    person p5 = p4;//这是拷贝构造
//}
//int main()
//{
//    test01();
//    return 0;
//}
//

//对象的初始化和清理
// 1 生活中买的电子产品都有出厂设置 删除数据保证安全
// 2 C++面向的对象来源于生活 每个对象都会有初始设置以及对象销毁前的清理数据的设置

//构造函数和析构函数
    //对象的初始化清理也是两个非常重要的安全问题
    //    一个对象或者变量没有初始化状态，对其使用后果是未知的
	   // 同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题

    //C++中利用了构造函数和析构函数解决以上问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作
    //对象的初始化和清理工作是编译器强制要我们做的事情，因此  ：：：如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现

  //・构造函数：主要作用于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
  //・析构函数：主要作用于对象销毁前系统自动调用，执行一些清理操作

//构造函数语法：类名(){}
//1 构造函数 没有返回值也不写void
//2 函数名称与类名相同
//3 构造函数可以有参数 所以可以发生重载
//4 程序在调用的时候 会自动调用构造 无需手动调用 而且只会调用一次

//析构函数语法：～类名(){}
//1 析构函数，没有返回值也不写void
//2 函数名称与类名相同 在名称前面加上符号～
//3 析构函数不可以有参数 因此不可以发生重载
//4 程序在销毁前会自动调用析构，无需手动调用 而且只会调用一次


//初始化和清理
//1 构造函数 进行初始化操作
//class person
//{
//public:
//    //1.1 构造函数
//    //构造函数 没有返回值也不写void
//    //函数名称与类名相同
//    //构造函数可以有参数 所以可以发生重载
//    //程序在调用的时候 会自动调用构造 无需手动调用 而且只会调用一次
//    person()
//    {
//        cout << "person构造函数调用" << endl;//如果不写的话 也会执行 但是是空代码 打印出来是空的
//    }
//    //2 析构函数 进行清理操作
//    //析构函数，没有返回值也不写void
//    //函数名称与类名相同 在名称前面加上符号～  使用这个符号~也可以
//    //析构函数不可以有参数 因此不可以发生重载
//    //程序在销毁前会自动调用析构，无需手动调用 而且只会调用一次
//    ~person()
//    {
//        cout << "person析构函数调用" << endl;
//
//    }
//
//};
////构造和析构 都是必须有的 如果我们自己不提供 编译器会提供一个空实现的构造和析构
//void test01()
//{
//    //对象建立在栈上 test01执行完之后就会释放(自动销毁) 所以根据析构函数的的特点就会调用析构函数
//    person p;//没有写括号 只有对象p就会自动调用这个函数
//  
//}
//int main()
//{
//    //test01();
//    person p;
//    system("pause");//当加上之后使程序停止 因为程序还没结束 所以就不会调用析构4
//	return 0;
//}