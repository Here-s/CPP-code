#define _CRT_SECURE_NO_WARNINGS 1
#include<iostream>
using namespace std;


//深拷贝和浅拷贝 （经典面试问题）
//浅拷贝：简单的赋值拷贝操作    浅拷贝带来的问题就是堆区的内存重复释放   解决方法就是自己再写一个拷贝函数 再在堆区申请一块内存 
		//存放拷贝的数据  但地址不一样  堆区指向的数据是一样的 但指针指向的内存是不一样的 这样就不会交叉释放了 就不会内存重复释放了
//深拷贝：在堆区重新申请空间，进行拷贝操作   自己在堆区创建一块内存
//析构代码：将堆区创建的数据释放

class person
{
public:
	person()
	{
		cout << "person的默认构造函数调用" << endl;
	}
	person(int aage,int aheight)
	{
		age = aage;
		height=new int(aheight);//利用new来把身高创建在堆区  用指针来接收堆区的数据 new返回的是地址 
		//这个地址保存了aheight的值 所以用指针地址接收  堆区的内存由程序员手动开辟  也由程序员手动释放
		//在程序结束的时候释放  在析构的时候  程序就执行完了 所以在析构的时候释放
		cout << "person的有参构造函数调用" << endl;
	}

	//自己实现一个拷贝构造函数来解决浅拷贝带来的问题
	person(const person& p)
	{
		cout << "自己实现的拷贝构造函数的调用" << endl;
		age = p.age;
		//height = p.height;//编译器默认实现就是这样的代码 但会出现堆区内存重复释放
		//通过深拷贝实现
		height = new int(*p.height);//把那块内存解引用 然后指向新的空间
		
	}
	~person()//这里写的析构代码 p1 p2 都会指向析构  释放的顺序是先进后出 就是先进来的 最后释放 所以是p2先释放
		//p2先释放 就把复制过来的地址给释放了 就是把160这块内存释放了  当p1释放的时候 已经被p2释放过了 所以p1
		//所以p1再次去释放的时候 就已经是非法访问了  浅拷贝的问题使用深拷贝来解决
		//就是自己再写一个拷贝函数 再在堆区申请一块内存 存放160 但地址可能是 0x00002 让p2指向0x00002 不指向0x00001
		//堆区指向的数据是一样的 但指针指向的内存是不一样的 这样就不会交叉释放了
	{
		//析构代码 将堆区开辟的数据做释放
		if (height != NULL)
		{
			delete height;
			height = NULL;//这样的话 程序会奔溃  因为创建了两个对象 每个对象都有两个属性 一个是年龄 一个是身高
			//如果利用编译器提供的拷贝构造函数，会做浅拷贝的操作  就是逐字节的把18拷到p2身上
			//还有体重 因为是指针 指针在堆区开辟了一块空间 放的身高是160 p1记录的是地址 拷贝的时候是把地址一模一样拷贝过去了
			//比如p1的地址是0x00001  拷贝的地址也是0x00001  所以p2记录的指针也是0x00001  代码就是这里出现问题了
		}
		cout << "person的析构函数调用" << endl;
	}
	int age;
	int* height;//加一个指针 来表示身高 
};
void test01()
{
	person p1(18,160);//创建对象 对年龄进行赋值操作  因为传的参数是18  所以调用有参构造函数 对年龄赋值为18
	cout << "p1的年龄是  " << p1.age << "p1身高是  " << *p1.height << endl;
	person p2(p1);//p2是p1的拷贝构造函数
	cout << "p2的年龄是  " << p2.age << "p2身高是  " << *p2.height << endl;
}
int main()
{
	test01();
	return 0;
}


//构造函数调用规则
//默认情况下 C++编译器至少给一个类添加3个函数
//1 默认构造函数（无参 函数体为空）
//2 默认析构函数（无参 函数体为空）
//3 默认拷贝构造函数 对属性进行值拷贝（值拷贝）

//构造函数调用规则如下：
//1 如果用户定义有参构造函数，C++不在提供默认无参构造，但是会提供默认拷贝构造 (就是不提供默认构造函数了)
//2 如果用户定义拷贝构造函数，C++不会再提供其他构造函数 (也就是编译器不提供另外两个)
//class person
//{
//public:
//	//person()
//	//{
//	//	cout << "person的默认构造函数调用" << endl;
//	//}
//	//person(int aage)
//	//{
//	//	cout << "person的有参构造函数调用" << endl;
//	//	age = aage;
//	//}
//	person(const person& p)
//	{
//		cout << "person的拷贝构造函数调用" << endl;
//		age = p.age;//当注释之后 编译器也会继续执行拷贝操作 所以得到的值还是18
//	}
//	~person()
//	{
//		cout << "person的析构函数调用" << endl;
//	}
//	int age;
//};
//void test01()
//{
//	person p;//默认构造函数调用
//	p.age = 18;
//	person p2(p);//p2是p的拷贝构造函数  p2的年龄是拷贝的p1的 所以也是18岁
//	cout << "p2的年龄" << p2.age << endl;
//}

//如果我们写了有参构造函数，编译器就不再提供默认构造  但依然提供拷贝构造
//void test02()
//{
//	//person p; //当我们写了有参构造函数，编译器就不再提供默认构造  但依然提供拷贝构造就像这样 把代码注释之后  
//	//把代码注释之后 就会报错：不存在默认构造函数 
//	person p(28);//如果我没写拷贝构造函数的话 系统会默认弄一个值拷贝构造
//	person p2(p);
//	cout << "p2的年龄是  " << p2.age << endl;
//}

//如果我们写了拷贝构造函数 编译器就不再提供其它普通构造函数了(不提供默认构造函数）
//void test03()
//{
//	//person p;//我们没写默认构造函数 因为有了拷贝构造函数 所以系统不提供默认构造函数 所以会报错
//}
//int main()
//{
//	//test01();
//	//test02();
//	//test03();
//	return 0;
//}